{
    "C:\\Users\\t.kubera\\dev\\hackathon\\targets\\IIRA\\app.py": [
        {
            "App": {
                "__init__": "\"\"\"\nInitializes the main application window for the IIRA system.\n\nThis method sets up the main window with a title, geometry, and minimum size. It configures the grid layout, initializes the database interaction, loads icons, and sets the theme for the application. It also initializes all frames used in the application and displays the main frame.\n\"\"\"",
                "show_frame": "\"\"\"Raises the specified frame to the top of the stack in the application window.\n\nArgs:\n    frame_name (str): The name of the frame to be raised.\n\"\"\"",
                "load_icons": "\"\"\"\nLoads and initializes all the icons used in the application from the specified file paths.\n\nThis method sets up various icons for the application interface, including icons for app logo, file selection, home, profile, help, face, rate, analyse, tooltip, save, delete, light mode, dark mode, unchecked, and checked states. These icons are loaded as `ImageTk.PhotoImage` objects and are stored as attributes of the App class.\n\"\"\"",
                "init_root_frame": "\"\"\"Initializes and positions the root frame within the main application window.\n\nThis method sets the provided frame to occupy the entire grid cell at the top-left\ncorner of the application window, stretching it to fill the entire space available.\n\nArgs:\n    frame (tk.Frame): The frame to be initialized and positioned.\n\"\"\"",
                "init_frames": "\"\"\"\nInitializes and configures the main frames of the application.\n\nThis method sets up the main frames used in the application by first clearing any existing widgets in each frame and then creating and configuring new instances of each frame type. It ensures that each frame is properly grid positioned and stored in the application's frame dictionary for easy access and management.\n\"\"\"",
                "App": "\"\"\"\nThe `App` class is designed to manage the graphical user interface of the IIRA system, handling the initialization and dynamic management of frames, icons, and the main application window.\n\nThis class provides methods to initialize the application, including setting up the main window, loading necessary icons, and configuring frames for different functionalities within the application. It allows for switching between different frames dynamically, ensuring a smooth user experience.\n\"\"\""
            }
        },
        {
            "global": {}
        }
    ],
    "C:\\Users\\t.kubera\\dev\\hackathon\\targets\\IIRA\\__init__.py": [
        "This file is empty."
    ],
    "C:\\Users\\t.kubera\\dev\\hackathon\\targets\\IIRA\\core\\create_analyses.py": [
        {
            "CreateAnalyses": {
                "__init__": "\"\"\"\nInitialize the CreateAnalyses class with necessary data for performing intra and inter analyses.\n\nParameters:\n    intra_id_list (list): List of IDs for intra analysis.\n    inter_id_list (list): List of IDs for inter analysis.\n    intra_metrics (object): Metrics object for intra analysis.\n    inter_metrics (object): Metrics object for inter analysis.\n    scale_format (str): The format of the scale used in the analysis.\n    categories (list): List of categories involved in the analysis.\n    weights (dict): Dictionary of weights for each category.\n    data (dict): Data used for the analysis, formatted according to the labels format in the FileValidation class.\n\"\"\"",
                "create_intra_analyses": "\"\"\"\nConducts intra-analysis for each ID in the intra_id_list using the provided data and metrics.\n\nThis method iterates over each ID in the intra_id_list, retrieves the corresponding intra-ratings,\nand computes the analysis using the Metrics class. The results are stored in the 'results' dictionary\nunder the 'intra' key, indexed by the ID. Debug information is printed if debugging is enabled.\n\"\"\"",
                "create_inter_analyses": "\"\"\"\nCompiles inter-rater analysis results based on the provided inter-rater IDs and metrics.\n\nThis method aggregates ratings from different raters for the same items, computes the analysis using the specified metrics, scale format, categories, and weights, and stores the results in the 'inter' key of the results dictionary.\n\"\"\"",
                "find_intra_ratings": "\"\"\"\nExtracts intra-rater ratings for a given ID from the dataset.\n\nThis method processes the data for a specific ID to compile the ratings given by the same rater across multiple instances.\nIt filters out entries where the label is missing or is a null value. It also ensures that only subjects rated more than once by the same rater are included in the final DataFrame, which is crucial for intra-rater reliability analysis.\n\nParameters:\n    id (int): The identifier for the rater whose intra-ratings are to be extracted.\n\nReturns:\n    pd.DataFrame: A DataFrame where the index represents the subjects and the columns contain the ratings given by the rater.\n\"\"\"",
                "find_inter_ratings": "\"\"\"\nCompiles inter-rater ratings from multiple raters into a structured DataFrame.\n\nThis method aggregates ratings from different raters specified in `self.inter_id_list` for each subject. It ensures that each subject's ratings are collected from all raters, avoiding duplicates that are only relevant for intra-rater analysis. The method constructs a dictionary where each key is a subject and the value is a list of ratings from different raters. This dictionary is then converted into a pandas DataFrame.\n\nReturns:\n    pandas.DataFrame: A DataFrame where the index represents the subjects and each row contains the list of ratings provided by different raters.\n\"\"\"",
                "CreateAnalyses": "\"\"\"\nThe CreateAnalyses class is designed to facilitate both intra-rater and inter-rater analyses using specified metrics, data, and configurations. It initializes with necessary parameters to set up the environment for these analyses and provides methods to conduct and retrieve results for intra and inter analyses separately. This class is essential for evaluating the consistency and reliability of ratings within and between different raters, making it suitable for statistical assessments in research studies or quality control processes.\n\"\"\""
            }
        },
        {
            "global": {}
        }
    ],
    "C:\\Users\\t.kubera\\dev\\hackathon\\targets\\IIRA\\core\\fileinteraction.py": [
        {
            "FileValidation": {
                "__init__": "```python\ndef __init__(self, file, scale_format):\n    \"\"\"\n    Initialize the FileValidation instance with a specified file and scale format.\n\n    This method sets up the initial state by determining the file type (Excel or CSV),\n    reading the file content, and initializing various attributes used for data processing.\n    It also performs initial checks and data extraction based on the file content and\n    specified scale format (nominal or ordinal).\n\n    Parameters:\n        file (str): The path to the file containing the data to be validated.\n        scale_format (str): The scale format of the data, which can be 'nominal' or 'ordinal'.\n    \"\"\"\n```",
                "check_format": "\"\"\"\nDetermines the format of the data file based on the column headers.\n\nThis method checks the column headers of the data file loaded into the `content` DataFrame.\nIt sets the `format` attribute of the class to \"Format 1\" if the header \"Rater ID\" is found,\nor to \"Format 2\" if the header \"Subject\" is found. If neither header is present, it raises a ValueError.\n\nRaises:\n    ValueError: If neither \"Rater ID\" nor \"Subject\" headers are found in the columns.\n\"\"\"",
                "find_categories": "```python\ndef find_categories(self):\n    \"\"\"\n    Extracts unique categories from the 'Categories' column of the content DataFrame.\n\n    This method iterates over each item in the 'Categories' column of the DataFrame stored in self.content.\n    It appends each non-null and unique category to the self.categories list attribute of the class.\n    \"\"\"\n```",
                "find_rater_ids": "```python\ndef find_rater_ids(self):\n    \"\"\"\n    Identifies and stores unique rater IDs from the dataset based on the specified format.\n\n    This method checks the format of the dataset and extracts rater IDs accordingly.\n    If the format is \"Format 1\", it extracts IDs from the \"Rater ID\" column.\n    If the format is \"Format 2\", it identifies headers that are not \"Subject\" and considers them as rater IDs.\n    Additionally, if the scale format is \"nominal\" or \"ordinal\", it further filters these headers to include only those that match the predefined categories.\n    \"\"\"\n```",
                "find_text": "```python\ndef find_text(self):\n    \"\"\"\n    Extracts and processes text data from the content based on the specified format and scale format.\n\n    This method identifies and extracts text data from the loaded content, applying different logic\n    based on the current format ('Format 1' or 'Format 2') and scale format ('nominal' or 'ordinal').\n    The extracted text is then processed using the `nlp` method to format it appropriately.\n\n    For 'Format 1':\n        - If the scale format is 'nominal' or 'ordinal', it extracts headers that are not in the\n          categories or rater IDs and processes them.\n        - Otherwise, it processes all headers except 'Rater ID'.\n    For 'Format 2':\n        - It processes the 'Subject' column values.\n\n    The processed text is stored in `self.text` and the formatted version in `self.formatted_text`.\n    \"\"\"\n```",
                "find_labels": "\"\"\"\nExtracts and organizes labels from the dataset based on the specified format and scale format.\n\nThis method processes the dataset to associate text entries with their corresponding labels based on the rater's ID.\nIt handles two different data formats:\n- Format 1: Assumes a direct mapping between 'Rater ID' and text entries.\n- Format 2: Uses 'Subject' as a key to map raters to their ratings.\n\nThe labels are stored in a dictionary where each key is a rater's ID and the value is a list of tuples.\nEach tuple contains a formatted text entry and its associated label as rated by the rater.\n\"\"\"",
                "write_file": "```python\ndef write_file(self, path, ratings):\n    \"\"\"\n    Writes the combined data of old and new ratings to a file specified by the path.\n\n    This method processes the ratings provided, combines them with existing data,\n    and writes the result to a file. The file format is determined by the file extension\n    in the path. Supported formats include .xlsx, .xls, .ods, and CSV.\n\n    Parameters:\n    - path (str): The file path where the data will be written. The file extension determines the format.\n    - ratings (list of tuples): A list of tuples, where each tuple contains the profile and rating.\n\n    The method handles different data formats and scale formats, and it appends a timestamp to new entries.\n    \"\"\"\n```",
                "usr_to_id": "```python\ndef usr_to_id(self, user):\n    \"\"\"\n    Generate a unique identifier for a user by prefixing a given username with 'ir_app_'.\n\n    Parameters:\n        user (str): The username for which the identifier will be generated.\n\n    Returns:\n        str: A unique identifier for the user.\n    \"\"\"\n```",
                "nlp": "```python\ndef nlp(self, text):\n    \"\"\"\n    Process and format the input text by extracting the most relevant content within brackets and removing numeric suffixes.\n\n    This method is specifically designed to handle text that includes metadata about sentence polarity. It extracts the\n    main content within brackets and removes any trailing numeric suffixes from the text, which are often present in\n    structured or semi-structured data formats.\n\n    Parameters:\n    - text (str): The text to be processed, which may include metadata and numeric suffixes.\n\n    Returns:\n    - str: The processed text with relevant content extracted and numeric suffixes removed.\n    \"\"\"\n```",
                "FileValidation": "\"\"\"\nThe `FileValidation` class is designed to handle and validate data from various file formats, primarily focusing on Excel and CSV files. It provides functionality to initialize data processing based on file content and specified scale formats (nominal or ordinal), determine file formats, extract and process unique categories, rater IDs, and text data, and organize labels according to the data format and scale format. Additionally, the class supports writing processed data to files, generating unique identifiers for users, and formatting text data for further analysis. This class is essential for applications requiring detailed data validation and processing, ensuring data integrity and proper formatting for analytical purposes.\n\"\"\""
            }
        },
        {
            "DBInteraction": {
                "__init__": "```python\ndef __init__(self, file, scale_format):\n    \"\"\"\n    Initialize the FileValidation instance with a specified file and scale format.\n\n    This method sets up the initial state by determining the file type (Excel or CSV),\n    reading the file content, and initializing various attributes used for data processing.\n    It also performs initial checks and data extraction based on the file content and\n    specified scale format (nominal or ordinal).\n\n    Parameters:\n        file (str): The path to the file containing the data to be validated.\n        scale_format (str): The scale format of the data, which can be 'nominal' or 'ordinal'.\n    \"\"\"\n```",
                "load_profiles": "```python\ndef load_profiles(self):\n    \"\"\"\n    Load profiles from the database into the instance.\n\n    This method initializes the active profile and loads additional profiles from the database.\n    If the database contains profiles, the first profile is set as the active profile and the rest are loaded into the profiles list.\n    If there are no profiles in the database, the method returns without making any changes.\n    \"\"\"\n```",
                "create_profile": "```python\ndef create_profile(self, new_profile):\n    \"\"\"\n    Creates a new profile and updates the active profile to the newly created one.\n\n    This method appends the current active profile to the list of profiles if it is not empty,\n    then sets the new profile as the active profile and updates the database with the new profile information.\n\n    Parameters:\n    - new_profile (str): The name of the new profile to be created and set as active.\n\n    Returns:\n    None\n    \"\"\"\n```",
                "delete_profile": "\"\"\"\nDeletes the currently active profile from the database, making the first profile in the list the new active profile. Updates the database accordingly.\n\"\"\"",
                "change_profile": "\"\"\"\nSwitches the active profile to a specified profile and updates the database accordingly.\n\nThis method changes the currently active profile to the one specified by the 'change_to' parameter.\nIt also updates the list of profiles by moving the newly activated profile to the active position\nand appending the previously active profile to the list of other profiles. After changing the profile,\nit calls `write_to_db` to save the changes to the database.\n\nParameters:\n    change_to (str): The profile name to which the active profile should be changed.\n\nReturns:\n    None\n\"\"\"",
                "write_to_db": "```python\ndef write_to_db(self):\n    \"\"\"\n    Writes the current profile data to the database file.\n\n    This method updates the database file by writing the active profile and the list of other profiles\n    into a DataFrame and then saving it to the specified database path in CSV format.\n    \"\"\"\n```",
                "DBInteraction": "\"\"\"\nA class designed to manage and interact with database profiles, specifically for handling user profiles within a database system. This class provides functionality to initialize the database interaction, load profiles, create new profiles, delete profiles, switch between profiles, and write changes back to the database.\n\nThe class supports operations such as initializing with a specific file and format, loading existing profiles from the database, creating new profiles and setting them as active, deleting the current active profile, changing the active profile, and persistently saving profile changes to the database.\n\"\"\""
            }
        },
        {
            "global": {
                "write_excel": "```python\ndef write_excel(analyse, intra_ids, intra_metrics, inter_ids, inter_metrics, scale_format, filename):\n    \"\"\"\n    Generates an Excel file with intra-rater and inter-rater analysis results.\n\n    This function creates an Excel workbook that includes detailed statistical analysis results\n    for both intra-rater and inter-rater evaluations based on provided metrics and IDs. The workbook\n    contains multiple sections formatted for clarity and ease of understanding, including bold headers\n    and structured data presentation.\n\n    Parameters:\n        analyse (Analysis): An object containing the analysis results.\n        intra_ids (list): List of IDs for intra-rater analysis.\n        intra_metrics (list): List of metrics to be reported for intra-rater analysis.\n        inter_ids (list): List of IDs for inter-rater analysis.\n        inter_metrics (list): List of metrics to be reported for inter-rater analysis.\n        scale_format (str): The scale format of the ratings ('nominal', 'ordinal', etc.).\n        filename (str): The path to the file where the Excel workbook will be saved.\n\n    Returns:\n        None: The function writes directly to an Excel file specified by `filename`.\n    \"\"\"\n```"
            }
        }
    ],
    "C:\\Users\\t.kubera\\dev\\hackathon\\targets\\IIRA\\core\\metrics.py": [
        {
            "Metrics": {
                "__init__": "\"\"\"\nInitialize the Metrics object with specified parameters for scale format, categories, ratings, and weights.\n\nThis constructor sets up the Metrics object by initializing various properties such as scale format, categories, ratings, and the number of subjects. It also determines the type of analysis to be performed based on the scale format, either using irrCAC for ordinal or nominal scales or using pingouin for other types of scales. Additionally, it sets the decimal precision context.\n\nParameters:\n    scale_format (str): The format of the scale, e.g., 'ordinal', 'nominal'.\n    categories (list): A list of categories applicable to the ratings.\n    ratings (DataFrame): A pandas DataFrame containing the ratings data.\n    weights (list): A list of weights corresponding to the categories.\n\"\"\"",
                "cohens_kappa": "```python\ndef cohens_kappa(self):\n    \"\"\"\n    Calculate and return the Cohen's Kappa coefficient value for the ratings.\n\n    This method computes the Cohen's Kappa coefficient, a statistical measure of inter-rater reliability\n    or agreement for qualitative (categorical) items. It is generally thought to be a more robust measure\n    than simple percent agreement calculation, as Kappa takes into account the agreement occurring by chance.\n\n    Returns:\n        float: The Cohen's Kappa coefficient value.\n    \"\"\"\n```",
                "fleiss_kappa": "\"\"\"\nCalculates and returns the Fleiss' kappa coefficient value for the given ratings.\n\nFleiss' kappa is a statistical measure for assessing the reliability of agreement between a fixed number of raters when assigning categorical ratings to a number of items. This method retrieves the Fleiss' kappa value from the analysis results, which quantifies the degree of agreement over that expected by chance.\n\nReturns:\n    float: The Fleiss' kappa coefficient value.\n\"\"\"",
                "gwets_ac": "\"\"\"\nCalculates and returns the Gwet's AC coefficient value for the current analysis.\n\nGwet's AC is a statistical measure used to assess the agreement between raters. It is particularly useful when dealing with ordinal or nominal data and can provide a robust alternative to other agreement coefficients like Cohen's Kappa, especially in the presence of high agreement or when the assumption of independence among raters is violated.\n\nReturns:\n    float: The Gwet's AC coefficient value from the analysis.\n\"\"\"",
                "krippendorfs_alpha": "\"\"\"\nCalculates and returns the Krippendorff's alpha coefficient value for inter-rater reliability.\n\nThis method computes the Krippendorff's alpha, a statistical measure of the agreement achieved when coding a set of units based on the level of measurement specified. It is used to assess the reliability of raters (inter-rater reliability).\n\nReturns:\n    float: The Krippendorff's alpha coefficient value rounded to four decimal places.\n\"\"\"",
                "g_index": "\"\"\"\nCalculates the G index, a measure of agreement that adjusts the observed agreement for the probability of chance agreement among categories.\n\nThe G index is computed using the formula:\n    G = (P_a - 1/q) / (1 - 1/q)\nwhere P_a is the overall agreement and q is the number of categories.\n\nReturns:\n    float: The G index rounded to four decimal places.\n\"\"\"",
                "icc": "\"\"\"\nCalculates the Intraclass Correlation Coefficient (ICC) for assessing the reliability of measurements where quantitative measurements are made on units that are organized into groups.\n\nIt constructs a DataFrame from the ratings data, specifying targets, raters, and ratings, and then uses the `pingouin.intraclass_corr` function to compute the ICC, handling missing data according to the specified policy.\n\nReturns:\n    A pandas DataFrame containing the ICC results, rounded to four decimal places.\n\"\"\"",
                "overall_agreement": "\"\"\"\nCalculates the overall agreement among raters for a given set of ratings.\n\nThis method computes the proportion of agreement among raters, adjusted for the number of categories and replications. It supports two scenarios:\n1. When there are exactly two replications, it calculates the proportion of subjects that received the same category rating from both replications.\n2. When there are more than two replications, it calculates the agreement based on a more complex formula that considers all possible pairs of ratings for each subject.\n\nReturns:\n    decimal.Decimal: The overall agreement proportion.\n\nRaises:\n    ValueError: If there are fewer than two replications per subject, making it impossible to calculate an overall agreement.\n\"\"\"",
                "Metrics": "\"\"\"\nThe Metrics class provides a comprehensive suite of statistical methods to assess the reliability and agreement of ratings across different raters. It supports various scales and measurement types, including ordinal, nominal, and interval scales. The class is designed to handle multiple raters and categories, offering calculations of several inter-rater reliability coefficients such as Cohen's Kappa, Fleiss' Kappa, Gwet's AC, Krippendorff's Alpha, and the Intraclass Correlation Coefficient (ICC). Additionally, it includes methods to compute overall agreement and specific indices like the G index. This class is essential for statistical analysis in fields where agreement measurement is crucial, such as psychology, medical research, and any other domain where qualitative or quantitative assessments are made by multiple observers.\n\"\"\""
            }
        },
        {
            "global": {
                "map_metrics": "```python\ndef map_metrics(metric):\n    \"\"\"\n    Maps a human-readable metric name to its corresponding method name in the analysis object.\n\n    Args:\n    metric (str): A string representing the name of the metric. This can be one of the following:\n                  \"Cohen's-|Conger's \u03ba\", \"Fleiss' \u03ba\", \"Krippendorff's \u03b1\", \"Gwet's AC\".\n\n    Returns:\n    str: The method name as a string that corresponds to the given metric.\n    \"\"\"\n```"
            }
        }
    ],
    "C:\\Users\\t.kubera\\dev\\hackathon\\targets\\IIRA\\core\\__init__.py": [
        "This file is empty."
    ],
    "C:\\Users\\t.kubera\\dev\\hackathon\\targets\\IIRA\\data\\__init__.py": [
        "This file is empty."
    ],
    "C:\\Users\\t.kubera\\dev\\hackathon\\targets\\IIRA\\gui\\analyseframe.py": [
        {
            "AnalyseFrame": {
                "__init__": "```python\ndef __init__(self, container):\n    \"\"\"\n    Initialize the AnalyseFrame with a specified container.\n\n    This method sets up the frame for analysis, including the configuration of various\n    metrics for intra-rater and inter-rater reliability analysis. It also initializes\n    the GUI components such as buttons, labels, and frames necessary for the analysis\n    process.\n\n    Args:\n    container (tk.Widget): The parent widget in which this frame is contained.\n    \"\"\"\n```",
                "analyse_start": "```python\ndef analyse_start(self, container):\n    \"\"\"\n    Initiates the analysis process based on selected rater IDs and metrics.\n\n    This method collects all selected intra-rater and inter-rater metrics and IDs,\n    validates the selections, and proceeds to display the results in the ResultsFrame.\n    It handles various validation checks such as ensuring there are enough raters for\n    inter-rater analysis and that metrics and rater IDs are selected before proceeding.\n\n    Parameters:\n        container (tk.Frame): The parent container which holds the frame structure.\n\n    Raises:\n        tk.messagebox.showerror: If there is an invalid input such as only one rater ID\n                                 for inter-rater analysis or no metrics/rater IDs selected.\n    \"\"\"\n```",
                "populate_rater_container": "```python\ndef populate_rater_container(self):\n    \"\"\"\n    Populates the rater container with rater IDs and their corresponding checkbuttons for intra-rater and inter-rater selections.\n\n    This method retrieves a list of rater IDs from the container's `rater_ids` attribute, initializes checkbutton variables\n    for each rater ID for both intra-rater and inter-rater analysis, and creates a table in the rater container frame with\n    these checkbuttons. Each row in the table corresponds to a rater ID and includes checkbuttons to select or deselect\n    that ID for intra-rater and inter-rater analysis.\n    \"\"\"\n```",
                "populate_metrics_container": "\"\"\"\nPopulates the metrics container based on the scale format of the data. It dynamically adjusts the available metrics\nfor intrarater and interrater analysis based on the scale format (nominal, ordinal, interval, or rational).\nIt then creates a table displaying these metrics with options to select for analysis.\n\"\"\"",
                "map_metric_to_var": "```python\ndef map_metric_to_var(self, mode, metric_name):\n    \"\"\"\n    Maps a given metric name to its corresponding tkinter variable based on the mode.\n\n    Args:\n    mode (str): Specifies the mode as either 'intra' or 'inter'.\n    metric_name (str): The name of the metric to map.\n\n    Returns:\n    tkinter.IntVar: The tkinter variable associated with the given metric name and mode.\n    \"\"\"\n```",
                "toggle": "```python\ndef toggle(self, mode):\n    \"\"\"\n    Toggles the selection state of all IDs or metrics based on the provided mode.\n\n    This method checks if all IDs or metrics are selected. If they are, it deselects all;\n    otherwise, it selects all. It also updates the button text accordingly to reflect the\n    current state (either \"Alle ausw\u00e4hlen\" for select all or \"Alle abw\u00e4hlen\" for deselect all).\n\n    Parameters:\n    - mode (str): Determines the type of items to toggle. Accepts 'id' for toggling rater IDs\n                  or 'metric' for toggling metrics.\n    \"\"\"\n```",
                "help_cmd": "```python\ndef help_cmd(self, event=None):\n    \"\"\"\n    Opens a help frame specific to the preparation and analysis phase.\n    This frame provides guidance and information related to the analysis setup process.\n    \"\"\"\n```",
                "update_frame": "\"\"\"\nUpdates the frame by populating it with dynamically generated data. It calculates the results based on selected metrics and IDs, then populates the intra-rater and inter-rater results sections accordingly.\n\"\"\"",
                "AnalyseFrame": "\"\"\"\nThe AnalyseFrame class is designed to facilitate the analysis of intra-rater and inter-rater reliability within a graphical user interface. It provides functionalities to initialize the analysis environment, populate it with necessary components like rater IDs and metrics, and manage the analysis process. This class handles user interactions, data validation, and result display, ensuring a comprehensive and user-friendly interface for reliability analysis tasks.\n\"\"\""
            }
        },
        {
            "ResultsFrame": {
                "__init__": "```python\ndef __init__(self, container):\n    \"\"\"\n    Initialize the AnalyseFrame with a specified container.\n\n    This method sets up the frame for analysis, including the configuration of various\n    metrics for intra-rater and inter-rater reliability analysis. It also initializes\n    the GUI components such as buttons, labels, and frames necessary for the analysis\n    process.\n\n    Args:\n    container (tk.Widget): The parent widget in which this frame is contained.\n    \"\"\"\n```",
                "calculate_results": "```python\ndef calculate_results(self):\n    \"\"\"\n    Calculate the reliability analyses based on the selected intra-rater and inter-rater IDs and metrics.\n    \n    This method initializes the reliability analyses using the selected IDs and metrics, along with\n    additional parameters such as scale format, categories, weights, and labels from the container.\n    The results are stored in the `reliability_analyses` attribute of the instance.\n    \"\"\"\n```",
                "populate_intra_results": "```python\ndef populate_intra_results(self):\n    \"\"\"\n    Populates the intrarater results tab with calculated reliability metrics for selected intra-rater IDs.\n\n    This method dynamically generates a table displaying the reliability metrics for each selected rater ID.\n    It includes metrics such as Cohen's kappa, Fleiss' kappa, Krippendorff's alpha, Gwet's AC, and ICC,\n    depending on the scale format (nominal, ordinal, interval, or ratio) and the selected metrics.\n    Additional information such as the number of subjects and replicates (if applicable) is also displayed.\n\n    The method handles cases where there are not enough ratings to compute the metrics, and it provides\n    detailed debug information if the debug mode is enabled.\n    \"\"\"\n```",
                "populate_inter_results": "\"\"\"\nPopulates the inter-rater results tab with calculated metrics and displays them in a table format.\n\nThis method checks if there are selected inter-rater IDs and metrics, and if so, it adds a new tab to the notebook widget for displaying inter-rater results. It constructs the table headers based on the selected metrics and, depending on the scale format, adds columns for the number of subjects and raters. The method calculates the metric values using the results from the reliability analyses and displays them in the table. Additionally, it provides information about the scale format and weights used in the analysis.\n\"\"\"",
                "export_cmd": "\"\"\"\nExport the reliability analysis results to a file.\n\nThis method prompts the user to specify a filename and file type, then exports the\nreliability analysis results to the chosen file format. Supported formats include\nExcel (.xlsx, .xls), LibreOffice Calc (.ods), and CSV (.csv). The method uses the\n`write_excel` function to handle the actual file writing process.\n\"\"\"",
                "help_cmd": "```python\ndef help_cmd(self, event=None):\n    \"\"\"\n    Opens a help frame specific to the preparation and analysis phase.\n    This frame provides guidance and information related to the analysis setup process.\n    \"\"\"\n```",
                "update_frame": "\"\"\"\nUpdates the frame by populating it with dynamically generated data. It calculates the results based on selected metrics and IDs, then populates the intra-rater and inter-rater results sections accordingly.\n\"\"\"",
                "ResultsFrame": "\"\"\"\nA class designed to manage and display reliability analysis results within a graphical user interface.\n\nThis class, ResultsFrame, is responsible for initializing the analysis environment, calculating reliability metrics, and displaying these metrics for intra-rater and inter-rater reliability analyses. It supports various statistical methods and handles the export of results to different file formats. The class also provides a help section to guide users through the analysis process.\n\nAttributes:\n    container (tk.Widget): The parent widget in which this frame is contained.\n    reliability_analyses (dict): Stores the results of the reliability analyses.\n\nMethods:\n    __init__(self, container): Initializes the frame with necessary GUI components.\n    calculate_results(self): Performs the reliability calculations.\n    populate_intra_results(self): Displays intra-rater reliability metrics.\n    populate_inter_results(self): Displays inter-rater reliability metrics.\n    export_cmd(self): Exports the analysis results to a file.\n    help_cmd(self, event=None): Provides help related to the analysis setup.\n    update_frame(self): Updates the frame with new data and recalculates results.\n\"\"\""
            }
        },
        {
            "global": {
                "[]": "```python\ndef analyse_start(self, container):\n    \"\"\"\n    Initiates the analysis process based on selected metrics and rater IDs.\n\n    This method collects all selected intra-rater and inter-rater metrics and IDs,\n    checks for valid selections, and proceeds to display the results in the ResultsFrame.\n    If the selections are invalid (e.g., only one inter-rater ID selected or no metrics selected),\n    it shows an error message and resets the selections.\n\n    Args:\n    - container: The main application container which holds different frames including the ResultsFrame.\n\n    Raises:\n    - tk.messagebox.showerror: If the input conditions are not met, it shows an appropriate error message.\n    \"\"\"\n```"
            }
        }
    ],
    "C:\\Users\\t.kubera\\dev\\hackathon\\targets\\IIRA\\gui\\containerframe.py": [
        {
            "ContainerFrame": {
                "__init__": "\"\"\"\nInitialize the ContainerFrame with a specified container.\n\nThis method sets up the frame within the given container, configures the style, and initializes the menu bar.\n\nArgs:\n    container: The parent widget in which this frame will be placed.\n\"\"\"",
                "init_menu_bar": "\"\"\"\nInitializes the menu bar for the ContainerFrame by creating and configuring the menu items.\n\nThis method sets up the menu bar with 'Home', 'Profile', and 'Help' sections, each represented by a frame and a label. \nEach section is interactive, responding to mouse enter and leave events to change styles, and click events to execute specific commands.\n\"\"\"",
                "on_enter": "```python\ndef on_enter(self, frame, label):\n    \"\"\"\n    Handles the mouse entering an element by changing the frame and label styles.\n\n    This method is triggered when the mouse pointer enters the area of a frame or label.\n    It sets the frame's style to a predefined style with an accent color and changes\n    the background color of the label to the accent color.\n\n    Parameters:\n        frame (ttk.Frame): The frame that the mouse enters.\n        label (ttk.Label): The label within the frame whose background color is changed.\n    \"\"\"\n```",
                "on_leave": "\"\"\"\nRestores the default style and background color of the specified frame and label when the mouse leaves the frame.\n\nThis method is typically bound to the `<Leave>` event of a frame and its associated label. It resets the frame's style to the default 'TFrame' style and sets the label's background color to match the default background color of 'TFrame'.\n\nParameters:\n    frame (ttk.Frame): The frame that the mouse has left.\n    label (ttk.Label): The label within the frame that needs its background color reset.\n\"\"\"",
                "toggle_color_mode": "\"\"\"\nToggles the color mode of the application between light and dark themes.\n\nThis method checks the current state of `container.light_mode`. If it is True, it switches the theme to a dark mode ('forest-dark'). If False, it switches to a light mode ('forest-light'). This change affects the overall appearance of the application's GUI.\n\"\"\"",
                "create_table": "\"\"\"\nCreates a table in the specified parent widget using the provided headings and content.\n\nArgs:\n    parent (ttk.Widget): The parent widget where the table will be created.\n    headings (list): A list of strings representing the column headings.\n    content (list of lists): A list where each sublist represents a row of data.\n\nThe table is created with labels for headings and either labels or checkbuttons for each cell,\ndepending on the data type in the content list. Vertical separators are added between columns,\nand a horizontal separator is added after the headings.\n\"\"\"",
                "profile_cmd": "\"\"\"\nActivates the profile management interface by initializing and displaying the ProfileFrame.\n\nThis method is bound to the profile button in the GUI. When the profile button is clicked, this method is called to switch the current view to the ProfileFrame, allowing the user to manage their profile settings.\n\"\"\"",
                "home_cmd": "\"\"\"\nExecutes the home command which initializes and displays the main frame of the application.\n\nThis method reinitializes the frames within the container and sets the \"MainFrame\" as the visible frame, effectively bringing the user to the home screen of the application.\n\"\"\"",
                "help_cmd": "\"\"\"\nHandles the help command by raising a NotImplementedError when invoked.\n\nThis method is bound to the help button in the GUI. When the help button is clicked,\nthis method is triggered but currently does not have an implementation, indicating\nthat the functionality is yet to be developed or is intentionally left unimplemented.\n\nParameters:\n    event (optional): The event object that triggered this method. Defaults to None.\n\"\"\"",
                "update_frame": "\"\"\"\nUpdates the current frame in the GUI.\n\nThis method is intended to be implemented in derived classes, where it will handle the specifics of updating the GUI frame based on the context and state of the application. As it stands, it raises a NotImplementedError, indicating that it should be overridden in subclasses.\n\"\"\"",
                "ContainerFrame": "\"\"\"\nA GUI management class designed to operate within a container widget, handling various interactive elements and themes.\n\nThe ContainerFrame class is responsible for initializing and managing a graphical user interface within a specified container. It sets up the frame, configures styles, and initializes a menu bar with interactive elements. The class provides functionality to handle user interactions such as mouse enter and leave events, and commands associated with menu items like 'Home', 'Profile', and 'Help'. Additionally, it supports toggling between light and dark color themes and updating the GUI components dynamically.\n\nAttributes:\n    container (ttk.Widget): The parent widget in which this frame and its components are placed.\n\nMethods:\n    __init__(self, container): Initializes the frame within the given container.\n    init_menu_bar(self): Sets up the interactive menu bar.\n    on_enter(self, frame, label): Changes styles when the mouse enters a frame or label.\n    on_leave(self, frame, label): Restores styles when the mouse leaves a frame or label.\n    toggle_color_mode(self): Switches the GUI theme between light and dark modes.\n    create_table(self, parent, headings, content): Creates a table with specified headings and content.\n    profile_cmd(self): Activates the profile management interface.\n    home_cmd(self): Displays the main frame of the application.\n    help_cmd(self): Placeholder for help command functionality.\n    update_frame(self): Intended to be overridden to update the GUI frame in derived classes.\n\"\"\""
            }
        },
        {
            "global": {}
        }
    ],
    "C:\\Users\\t.kubera\\dev\\hackathon\\targets\\IIRA\\gui\\fileframes.py": [
        {
            "ScaleFrame": {
                "__init__": "```python\ndef __init__(self, container):\n    \"\"\"\n    Initialize the ScaleFrame with a specified container.\n\n    This method sets up the ScaleFrame within the given container, configuring the necessary styles,\n    variables, and layout for scale and weight selection interfaces. It also initializes the navigation\n    and display components within the frame.\n\n    Args:\n    container (ttk.Frame): The parent container in which this frame will be placed.\n    \"\"\"\n```",
                "populate_frame": "\"\"\"\nPopulates the frame with appropriate widgets based on the specified mode.\n\nThis method configures the frame's content dynamically depending on the mode provided.\nIf the mode is 'analyse', it populates both scale types and weights. For other modes,\nit only populates the scale types.\n\nParameters:\n    mode (str): The mode of operation which determines the widgets to be displayed.\n                Expected values are 'analyse' or other specific modes.\n\"\"\"",
                "populate_weights": "\"\"\"\nPopulates the weight selection interface in the GUI.\n\nThis method sets up the labels, dropdown menu, and information labels related to the weight options\nwithin the center container of the ScaleFrame. It configures the layout and ensures that the weight\nselection components are displayed correctly, providing users with options to choose how categories\nare weighted in their analysis.\n\"\"\"",
                "populate_scaletype": "```python\ndef populate_scaletype(self):\n    \"\"\"\n    Populates the scale type selection interface within the center container of the ScaleFrame.\n\n    This method sets up labels and an option menu for selecting the scale type, and provides\n    informational labels about each scale type. The scale types include nominal, ordinal,\n    interval, and ratio scales, each described with their characteristics to aid the user\n    in making an appropriate selection based on their data analysis needs.\n    \"\"\"\n```",
                "next_cmd": "\"\"\"\nAdvances the application state by setting the selected scale format and weight, and then transitions to the \"FileFrame\".\n\nThis method retrieves the selected scale format and, if the mode is \"analyse\", also retrieves the selected weight. It then updates the \"FileFrame\" based on these selections and displays it.\n\"\"\"",
                "help_cmd": "\"\"\"\nOpens a help dialog specific to the ScaleFrame, providing guidance on scale types and weight options.\n\"\"\"",
                "update_frame": "\"\"\"\nUpdates the frame by clearing existing widgets and repopulating based on the current mode.\nThis method is responsible for refreshing the visual components of the frame whenever\nthe underlying data or state changes, ensuring that the display is consistent with the\ncurrent application context.\n\"\"\"",
                "ScaleFrame": "\"\"\"\nThe ScaleFrame class is designed to be a versatile user interface component within a larger application, \ntypically for data analysis purposes. It facilitates user interaction for selecting scale types and weights \nappropriate for their data analysis needs. The class provides dynamic configuration of its content based \non different operational modes, such as 'analyse', and integrates functionalities to update and navigate \nthrough the application states.\n\nThis class manages the layout and behavior of widgets related to scale type and weight selection, \nincluding the initialization within a specified container, dynamic population of widgets based on the \nselected mode, and updating the frame as needed. It also includes methods for advancing the application \nstate and providing help related to the available options.\n\"\"\""
            }
        },
        {
            "FileFrame": {
                "__init__": "```python\ndef __init__(self, container):\n    \"\"\"\n    Initialize the ScaleFrame with a specified container.\n\n    This method sets up the ScaleFrame within the given container, configuring the necessary styles,\n    variables, and layout for scale and weight selection interfaces. It also initializes the navigation\n    and display components within the frame.\n\n    Args:\n    container (ttk.Frame): The parent container in which this frame will be placed.\n    \"\"\"\n```",
                "populate_format_preview": "```python\ndef populate_format_preview(self, format_container):\n    \"\"\"\n    Populates the specified format container with a preview of data format based on the selected scale format.\n\n    This method dynamically generates a preview of how data should be formatted in the file to be imported,\n    depending on whether the scale format is nominal, ordinal, or other types (like interval or ratio).\n    It adjusts the displayed information and table structure in the GUI to guide the user in preparing their data files correctly.\n\n    Args:\n    format_container (ttk.Frame): The container frame where the format preview will be displayed.\n\n    The method checks the current scale format and populates the appropriate format container with example data,\n    headers, and informational labels that explain the requirements for each data format.\n    \"\"\"\n```",
                "select_file": "\"\"\"\nOpens a file dialog for the user to select a file, and processes the selected file based on the current application mode.\n\nThis method allows the user to select a file from their file system with specific file types (.xlsx, .xls, .ods, .csv).\nAfter a file is selected, it validates and processes the file according to the scale format specified in the container.\nIf the file is valid, it updates the application state and transitions to the appropriate frame based on the mode ('analyse' or 'rate').\n\nParameters:\n    container (ContainerFrame): The container frame that holds the application state and manages transitions between frames.\n\nRaises:\n    messagebox: If the file import fails, an error message is displayed to the user.\n\"\"\"",
                "help_cmd": "\"\"\"\nOpens a help dialog specific to the ScaleFrame, providing guidance on scale types and weight options.\n\"\"\"",
                "update_frame": "\"\"\"\nUpdates the frame by clearing existing widgets and repopulating based on the current mode.\nThis method is responsible for refreshing the visual components of the frame whenever\nthe underlying data or state changes, ensuring that the display is consistent with the\ncurrent application context.\n\"\"\"",
                "FileFrame": "\"\"\"\nThe FileFrame class is designed to manage and interact with file data within a graphical user interface. It provides functionalities to initialize a frame within a container, select files from the file system, populate previews of data formats, and update the frame based on user interactions or data changes. This class is essential for applications that require data import, format validation, and dynamic display updates based on the selected data format and application mode. It also includes a help command to assist users with scale types and weight options, enhancing user experience and usability.\n\"\"\""
            }
        },
        {
            "global": {
                "[]": "```python\ndef select_file(self, container):\n    \"\"\"\n    Opens a file dialog for the user to select a file, validates the file, and updates the application state.\n\n    This method allows the user to select a file from their system using a file dialog. The selected file\n    is then validated based on the current scale format set in the container. If the file is valid, it updates\n    the application state with the file's data and navigates to the appropriate frame based on the application's\n    mode (e.g., 'analyse', 'rate'). If the file is not valid, it displays an error message.\n\n    Parameters:\n        container (ContainerFrame): The main application container that holds the state and other frames.\n\n    Returns:\n        None\n    \"\"\"\n```"
            }
        }
    ],
    "C:\\Users\\t.kubera\\dev\\hackathon\\targets\\IIRA\\gui\\helperframes.py": [
        {
            "ProfileFrame": {
                "__init__": "```python\ndef __init__(self, container):\n    \"\"\"\n    Initialize a new instance of the ProfileFrame class, which is a Toplevel window in a tkinter application.\n\n    This window is used for managing user profiles, including creating, deleting, and switching profiles.\n\n    Args:\n    container (tk.Tk): The parent window for this Toplevel window, typically the main application window.\n    \"\"\"\n```",
                "ok_cmd": "```python\ndef ok_cmd(self, event=None):\n    \"\"\"\n    Handles the 'Ok' button click or 'Return' key press event in the profile management dialog.\n\n    If the user input is empty, the dialog is closed. If there is user input, a new profile is created\n    with the provided name, and the profile-related UI elements are updated accordingly.\n\n    Parameters:\n    - event (Event, optional): The event that triggered this method. Defaults to None.\n\n    This method directly modifies the UI and interacts with the database to create a new profile.\n    \"\"\"\n```",
                "populate_profile_label": "```python\ndef populate_profile_label(self):\n    \"\"\"\n    Updates the text of the profile name label with the currently active profile name.\n    \"\"\"\n```",
                "populate_change_profile_menu": "```python\ndef populate_change_profile_menu(self):\n    \"\"\"\n    Populates the 'change profile' menu with radio buttons for each user profile.\n\n    This method dynamically creates a radio button for each profile stored in the database interaction layer.\n    Each radio button, when selected, triggers the `change_profile` method to switch to the corresponding profile.\n    \"\"\"\n```",
                "create_new_profile": "```python\ndef create_new_profile(self):\n    \"\"\"\n    Creates a new user profile by adding an input field to the GUI if it has not been added yet.\n\n    This method checks if the input field for entering a new profile name is already present.\n    If not, it adds a label and an entry widget to the separator frame for the user to input the new profile name.\n    The entry widget is bound to the `ok_cmd` method, which is triggered when the user presses the Return key.\n    \"\"\"\n```",
                "change_profile": "\"\"\"\nChanges the active user profile to the selected one and updates the profile label and menu.\n\nArgs:\n    profile_selection (str): The name of the profile to switch to.\n\"\"\"",
                "delete_profile": "\"\"\"\nDeletes the currently active profile after ensuring that it is not the only profile available.\n\nThis method checks if there are other profiles available. If no other profiles exist, it prevents\nthe deletion of the current profile and displays an error message. If other profiles are available,\nit proceeds to delete the current profile and updates the profile label and profile menu to reflect\nthe changes.\n\"\"\"",
                "ProfileFrame": "\"\"\"\nThe `ProfileFrame` class is designed to manage user profiles within a tkinter application. It provides functionality to create, delete, and switch between different user profiles. This class is responsible for handling the user interface related to profile management, including displaying the current profile, updating the list of profiles, and responding to user interactions such as creating or deleting profiles.\n\nThe class uses a Toplevel window to encapsulate all profile-related functionalities, making it a distinct and modular part of the application. It interacts with a database to store and retrieve profile information, ensuring that profile changes are persistent across sessions.\n\"\"\""
            }
        },
        {
            "ScrollFrame": {
                "onFrameConfigure": "```python\ndef onFrameConfigure(self, event):\n    \"\"\"\n    Adjusts the scroll region of the canvas to encompass the entire viewport frame.\n\n    This method is called whenever the viewport frame is reconfigured (e.g., resized).\n    It ensures that the scrollable area of the canvas matches the size of the frame\n    containing the widgets, allowing for proper scrolling behavior.\n\n    Parameters:\n    - event: The event that triggered this method, which can be a resize or similar.\n             This parameter is not used in the method but is necessary for event binding.\n    \"\"\"\n```",
                "onCanvasConfigure": "```python\ndef onCanvasConfigure(self, event):\n    \"\"\"\n    Adjusts the width of the canvas window to match the canvas width when the canvas size changes.\n\n    This method ensures that the viewport frame within the canvas adjusts its width to fill the\n    entire canvas when the canvas itself is resized, maintaining the layout consistency.\n\n    Parameters:\n    - event: A tkinter event object containing information about the canvas configuration change.\n    \"\"\"\n```",
                "onMouseWheel": "```python\ndef onMouseWheel(self, event):\n    \"\"\"\n    Handles the mouse wheel event for scrolling the canvas vertically across different platforms.\n\n    This method adjusts the vertical scroll position of the canvas based on the mouse wheel movement.\n    It supports different scrolling increments for Windows, macOS (Darwin), and Linux systems.\n\n    Args:\n        event: A mouse event that contains information about the scroll action.\n    \"\"\"\n```",
                "onEnter": "```python\ndef onEnter(self, event):                                                       # bind wheel events when the cursor enters the control\n    \"\"\"\n    Bind mouse wheel events to the canvas when the cursor enters the viewport frame.\n\n    This method checks the operating system and binds the appropriate mouse wheel event\n    to allow scrolling within the canvas. For Linux, it binds Button-4 and Button-5 for\n    scrolling. For other systems, it binds the general MouseWheel event.\n\n    Args:\n    event: The event that triggers this method, typically related to the cursor entering the viewport area.\n    \"\"\"\n    if platform.system() == \"Linux\":\n        self.canvas.bind_all(\"<Button-4>\", self.onMouseWheel)\n        self.canvas.bind_all(\"<Button-5>\", self.onMouseWheel)\n    else:\n        self.canvas.bind_all(\"<MouseWheel>\", self.onMouseWheel)\n```",
                "onLeave": "```python\ndef onLeave(self, event):\n    \"\"\"\n    Unbinds the mouse wheel scroll events when the cursor leaves the control area.\n\n    This method ensures that the scroll events are only active when the cursor is\n    within the viewport of the ScrollFrame, enhancing the user experience by preventing\n    unintended scrolls when the cursor is outside the intended area.\n\n    Parameters:\n    - event: The event that triggers this method, typically a cursor leaving the viewport area.\n    \"\"\"\n```",
                "ScrollFrame": "\"\"\"\nA ScrollFrame class in Python, typically used in GUI applications to provide a scrollable area for widgets.\n\nThis class manages a canvas and a viewport frame to allow for dynamic content that exceeds the visible area. It includes methods to handle resizing of the canvas and frame, as well as mouse wheel scrolling across different platforms. The class ensures that the scrollable area is properly adjusted when the frame is resized and that scrolling behavior is consistent and intuitive.\n\nKey functionalities include:\n- Adjusting the scroll region and width of the canvas based on size changes.\n- Binding and unbinding mouse wheel events for scrolling as the mouse enters or leaves the frame.\n- Handling vertical scrolling with the mouse wheel, with support for different operating systems.\n\nThis class is essential for creating a user-friendly, scrollable interface in applications where the amount of content exceeds the available display area.\n\"\"\""
            }
        },
        {
            "MainHelpFrame": {
                "__init__": "```python\ndef __init__(self, container):\n    \"\"\"\n    Initialize a new instance of the ProfileFrame class, which is a Toplevel window in a tkinter application.\n\n    This window is used for managing user profiles, including creating, deleting, and switching profiles.\n\n    Args:\n    container (tk.Tk): The parent window for this Toplevel window, typically the main application window.\n    \"\"\"\n```",
                "MainHelpFrame": "\"\"\"\nMainHelpFrame is a class designed to manage user profiles within a tkinter application. It provides functionality to create, delete, and switch between different user profiles. This class is typically used as a Toplevel window that acts as a secondary window to the main application window, allowing for separate management of user profiles in a contained and organized manner.\n\"\"\""
            }
        },
        {
            "ScaleHelpFrame": {
                "ScaleHelpFrame": "\"\"\"\nA class designed to provide a graphical user interface component specifically for assisting users with scaling options. This class includes methods for initializing the component, updating its state based on user interactions, and handling specific events related to scaling adjustments. It is typically used in applications where dynamic scaling of elements or data visualization is required, providing a user-friendly interface to control these adjustments.\n\"\"\""
            }
        },
        {
            "ImportHelpFrame": {
                "ImportHelpFrame": "\"\"\"\nA class designed to provide a user interface frame for importing various types of data or resources. \nThis frame likely includes functionalities such as loading files, parsing data, and handling import errors.\n\"\"\""
            }
        },
        {
            "PrepAnalyseHelpFrame": {
                "__init__": "```python\ndef __init__(self, container):\n    \"\"\"\n    Initialize a new instance of the ProfileFrame class, which is a Toplevel window in a tkinter application.\n\n    This window is used for managing user profiles, including creating, deleting, and switching profiles.\n\n    Args:\n    container (tk.Tk): The parent window for this Toplevel window, typically the main application window.\n    \"\"\"\n```",
                "ok_cmd": "```python\ndef ok_cmd(self, event=None):\n    \"\"\"\n    Handles the 'Ok' button click or 'Return' key press event in the profile management dialog.\n\n    If the user input is empty, the dialog is closed. If there is user input, a new profile is created\n    with the provided name, and the profile-related UI elements are updated accordingly.\n\n    Parameters:\n    - event (Event, optional): The event that triggered this method. Defaults to None.\n\n    This method directly modifies the UI and interacts with the database to create a new profile.\n    \"\"\"\n```",
                "populate_profile_label": "```python\ndef populate_profile_label(self):\n    \"\"\"\n    Updates the text of the profile name label with the currently active profile name.\n    \"\"\"\n```",
                "populate_change_profile_menu": "```python\ndef populate_change_profile_menu(self):\n    \"\"\"\n    Populates the 'change profile' menu with radio buttons for each user profile.\n\n    This method dynamically creates a radio button for each profile stored in the database interaction layer.\n    Each radio button, when selected, triggers the `change_profile` method to switch to the corresponding profile.\n    \"\"\"\n```",
                "create_new_profile": "```python\ndef create_new_profile(self):\n    \"\"\"\n    Creates a new user profile by adding an input field to the GUI if it has not been added yet.\n\n    This method checks if the input field for entering a new profile name is already present.\n    If not, it adds a label and an entry widget to the separator frame for the user to input the new profile name.\n    The entry widget is bound to the `ok_cmd` method, which is triggered when the user presses the Return key.\n    \"\"\"\n```",
                "change_profile": "\"\"\"\nChanges the active user profile to the selected one and updates the profile label and menu.\n\nArgs:\n    profile_selection (str): The name of the profile to switch to.\n\"\"\"",
                "delete_profile": "\"\"\"\nDeletes the currently active profile after ensuring that it is not the only profile available.\n\nThis method checks if there are other profiles available. If no other profiles exist, it prevents\nthe deletion of the current profile and displays an error message. If other profiles are available,\nit proceeds to delete the current profile and updates the profile label and profile menu to reflect\nthe changes.\n\"\"\"",
                "PrepAnalyseHelpFrame": "\"\"\"\nThe `PrepAnalyseHelpFrame` class is designed to manage user profiles within a tkinter-based GUI application. It provides functionalities to create, delete, and switch between different user profiles. The class also handles UI updates related to profile management, such as updating labels and menus to reflect the current profile status. This class is essential for applications that require user profile management to maintain separate user states, preferences, or other personalized data.\n\"\"\""
            }
        },
        {
            "ResultsHelpFrame": {
                "__init__": "```python\ndef __init__(self, container):\n    \"\"\"\n    Initialize a new instance of the ProfileFrame class, which is a Toplevel window in a tkinter application.\n\n    This window is used for managing user profiles, including creating, deleting, and switching profiles.\n\n    Args:\n    container (tk.Tk): The parent window for this Toplevel window, typically the main application window.\n    \"\"\"\n```",
                "ok_cmd": "```python\ndef ok_cmd(self, event=None):\n    \"\"\"\n    Handles the 'Ok' button click or 'Return' key press event in the profile management dialog.\n\n    If the user input is empty, the dialog is closed. If there is user input, a new profile is created\n    with the provided name, and the profile-related UI elements are updated accordingly.\n\n    Parameters:\n    - event (Event, optional): The event that triggered this method. Defaults to None.\n\n    This method directly modifies the UI and interacts with the database to create a new profile.\n    \"\"\"\n```",
                "populate_profile_label": "```python\ndef populate_profile_label(self):\n    \"\"\"\n    Updates the text of the profile name label with the currently active profile name.\n    \"\"\"\n```",
                "populate_change_profile_menu": "```python\ndef populate_change_profile_menu(self):\n    \"\"\"\n    Populates the 'change profile' menu with radio buttons for each user profile.\n\n    This method dynamically creates a radio button for each profile stored in the database interaction layer.\n    Each radio button, when selected, triggers the `change_profile` method to switch to the corresponding profile.\n    \"\"\"\n```",
                "create_new_profile": "```python\ndef create_new_profile(self):\n    \"\"\"\n    Creates a new user profile by adding an input field to the GUI if it has not been added yet.\n\n    This method checks if the input field for entering a new profile name is already present.\n    If not, it adds a label and an entry widget to the separator frame for the user to input the new profile name.\n    The entry widget is bound to the `ok_cmd` method, which is triggered when the user presses the Return key.\n    \"\"\"\n```",
                "change_profile": "\"\"\"\nChanges the active user profile to the selected one and updates the profile label and menu.\n\nArgs:\n    profile_selection (str): The name of the profile to switch to.\n\"\"\"",
                "delete_profile": "\"\"\"\nDeletes the currently active profile after ensuring that it is not the only profile available.\n\nThis method checks if there are other profiles available. If no other profiles exist, it prevents\nthe deletion of the current profile and displays an error message. If other profiles are available,\nit proceeds to delete the current profile and updates the profile label and profile menu to reflect\nthe changes.\n\"\"\"",
                "ResultsHelpFrame": "\"\"\"\nA class designed to manage user profiles within a tkinter application, providing functionality for creating, deleting, and switching between different user profiles. This class integrates with a database to store and retrieve profile information and updates the GUI accordingly to reflect changes in the profile data.\n\nThe class includes methods to handle user interactions such as button clicks and menu selections, dynamically update UI components like labels and menus with current profile information, and ensure a smooth and responsive user experience in profile management.\n\"\"\""
            }
        },
        {
            "RateHelpFrame": {
                "RateHelpFrame": "\"\"\"\nA class that provides a help dialog specific to the rating functionality within a software application.\n\nThis class, RateHelpFrame, is designed to assist users in understanding and utilizing the rating features of the software. It includes detailed guidance on navigating the rating interface, how to perform ratings, and how to manage user profiles during a rating session. The class is structured as a frame within a graphical user interface, making it both interactive and user-friendly.\n\nAttributes:\n    container (tk.Toplevel): The parent container for this frame, which is typically a top-level widget in a Tkinter application.\n\"\"\""
            }
        },
        {
            "global": {
                "[]": "```python\ndef callback(url):\n    \"\"\"\n    Opens the provided URL in the default web browser.\n\n    Args:\n    url (str): The URL to be opened.\n    \"\"\"\n```"
            }
        }
    ],
    "C:\\Users\\t.kubera\\dev\\hackathon\\targets\\IIRA\\gui\\mainframe.py": [
        {
            "MainFrame": {
                "__init__": "\"\"\"\nInitializes the MainFrame which is a container for various interactive elements and frames.\n\nThis method sets up the main GUI components including buttons, labels, and frames. It configures styles,\nhandles the creation of a profile if none exists, and organizes the layout of the main interface.\n\nArgs:\n    container (tk.Tk): The main application window which acts as the container for this frame.\n\"\"\"",
                "start_mode": "\"\"\"\nSwitches the application mode and updates the interface accordingly.\n\nThis method sets the application mode based on the provided argument and updates the relevant frame to reflect the new mode.\n\nParameters:\n    mode (str): The mode to switch to. Expected values are \"analyse\" or \"rate\".\n\"\"\"",
                "no_profile": "\"\"\"\nHandles the scenario where no user profile is detected by prompting the user to create a new profile.\n\nThis method creates a new top-level window that allows the user to enter a name for a new profile. If the user attempts to create a profile without providing a name, an error message is displayed. If a name is provided, the profile is created in the database, and the window is closed.\n\"\"\"",
                "help_cmd": "\"\"\"\nThis method, when called, creates and displays the main help frame for the application.\n\n:param event: Optional event parameter for handling events, defaults to None.\n\"\"\"",
                "MainFrame": "\"\"\"\nMainFrame is a central component of a GUI application designed to manage user interactions and interface layout.\n\nThis class initializes and organizes the main graphical components such as buttons, labels, and frames. It handles user profiles, allowing for creation if none exist, and supports switching between different application modes like 'analyse' or 'rate'. Additionally, it provides help and guidance to users through a dedicated help frame.\n\nThe MainFrame class serves as the backbone for managing the overall user interface and interaction flow of the application, ensuring a seamless user experience.\n\"\"\""
            }
        },
        {
            "global": {
                "start_mode": "\"\"\"\nSwitches the application mode and updates the interface accordingly.\n\nThis method sets the application mode based on the provided argument and updates the relevant frame to reflect the new mode.\n\nParameters:\n    mode (str): The mode to switch to. Expected values are \"analyse\" or \"rate\".\n\"\"\"",
                "no_profile": "\"\"\"\nHandles the scenario where no user profile is detected by prompting the user to create a new profile.\n\nThis method creates a new top-level window that allows the user to enter a name for a new profile. If the user attempts to create a profile without providing a name, an error message is displayed. If a name is provided, the profile is created in the database, and the window is closed.\n\"\"\"",
                "help_cmd": "\"\"\"\nThis method, when called, creates and displays the main help frame for the application.\n\n:param event: Optional event parameter for handling events, defaults to None.\n\"\"\""
            }
        }
    ],
    "C:\\Users\\t.kubera\\dev\\hackathon\\targets\\IIRA\\gui\\rateframe.py": [
        {
            "RateFrame": {
                "__init__": "```python\ndef __init__(self, container):\n    \"\"\"\n    Initialize the RateFrame with a reference to the container that holds the database interaction and GUI configuration.\n\n    Args:\n    container (ContainerFrame): The parent container frame that holds the database interaction object and GUI styling configurations.\n    \"\"\"\n```",
                "populate_navigation": "```python\ndef populate_navigation(self):\n    \"\"\"\n    Populates the navigation treeview with parent and child nodes based on the text data.\n\n    This method divides the text data into segments and creates a hierarchical view in the treeview widget.\n    Each parent node represents a group of text entries, and each child node represents a single text entry.\n    The method ensures that the first parent node and the first child node are expanded and focused upon initialization.\n    \"\"\"\n```",
                "randomize": "\"\"\"\nRandomizes the order of text entries and their corresponding ratings based on the specified mode.\n\nThis method can operate in two modes:\n- \"do\": Shuffles the text entries and their corresponding ratings randomly.\n- \"undo\": Restores the original order of text entries and their corresponding ratings using a previously stored state.\n\nParameters:\n    mode (str): The mode of operation, either \"do\" for shuffling or \"undo\" for restoring original order.\n\"\"\"",
                "doubleclick_treeview": "```python\ndef doubleclick_treeview(self, event):\n    \"\"\"\n    Handles the double-click event on a treeview item in the text preview.\n\n    This method identifies the treeview item that was double-clicked and updates the text display\n    based on the selected item. It also updates the category selection if a rating already exists for the item.\n\n    Parameters:\n    - event: The event object containing details about the double-click action.\n\n    The method updates the text index to reflect the selected item, populates the text display,\n    and sets the category variable if a rating exists. It ensures the focus is set back to the widget\n    after the operation.\n    \"\"\"\n```",
                "delete_questions": "\"\"\"\nDeletes all items from the text preview treeview within the RateFrame.\n\nThis method clears the entire treeview used for displaying text elements by removing\neach child node. It is typically used to reset the view when needed.\n\"\"\"",
                "populate_categories": "\"\"\"\nPopulates the category selection interface based on the scale format specified in the container.\n\nThis method dynamically creates and displays the appropriate input widgets for category selection in the rating interface.\nIf the scale format is 'intervall' or 'ratio', it sets up an entry field for numerical input. For other scale formats,\nit creates a series of radio buttons corresponding to the categories available in the container. Additionally, it binds\nnumeric hotkeys to these categories for quick selection if the scale format is 'nominal' or 'ordinal'.\n\"\"\"",
                "delete_categories": "```python\ndef delete_categories(self):\n    \"\"\"\n    Removes all category-related widgets from the rating button container.\n\n    This method iterates through all child widgets of the `rbtn_container` frame and destroys each one,\n    effectively clearing all category selection options (e.g., radio buttons) from the GUI.\n    \"\"\"\n```",
                "populate_text": "```python\ndef populate_text(self):\n    \"\"\"\n    Updates the text label in the GUI with the current text entry from the text list,\n    formatted to include newlines for better readability.\n\n    This method formats the current text entry to fit within the GUI's text display area,\n    ensuring that the text is broken into lines that do not exceed a certain length,\n    making it easier to read. It uses the `add_newlines` method to insert newlines at appropriate\n    positions based on the length of the text and the presence of uppercase characters.\n    \"\"\"\n```",
                "add_newlines": "```python\ndef add_newlines(self, text, n):\n    \"\"\"\n    Inserts newlines into the provided text to ensure that no line exceeds the specified length `n`.\n\n    This method first adjusts the maximum line length `n` based on the number of uppercase characters in the text.\n    It then attempts to break the text into lines that do not exceed this length, ideally breaking at space characters\n    to avoid breaking words. If a word itself is longer than `n`, it is split with a newline character.\n\n    Parameters:\n        text (str): The text to be processed.\n        n (int): The desired maximum number of characters per line.\n\n    Returns:\n        str: The processed text with newlines inserted to ensure that no line exceeds the length `n`.\n    \"\"\"\n```",
                "count_upper_case": "```python\ndef count_upper_case(self, text, n):\n    \"\"\"\n    Adjusts the maximum length of text based on the count of uppercase characters.\n\n    This method counts the number of uppercase characters in the provided text.\n    If the count of uppercase characters is at least half the length of the text,\n    it reduces the provided maximum length 'n' by 25%.\n\n    Parameters:\n        text (str): The text to analyze.\n        n (int): The initial maximum length to consider.\n\n    Returns:\n        int: The adjusted maximum length based on the count of uppercase characters.\n    \"\"\"\n```",
                "entry_input_cmd": "```python\ndef entry_input_cmd(self, event=None):\n    \"\"\"\n    Handles the input from the entry field for category ratings.\n\n    This method is triggered when the user presses the 'Return' key in the entry field.\n    It sets the category variable to the value entered, updates the ratings data structure,\n    moves to the next rating item, and clears the entry field.\n\n    Parameters:\n        event (tk.Event, optional): The event that triggered this method. Defaults to None.\n    \"\"\"\n```",
                "cat_hotkey_cmd": "```python\ndef cat_hotkey_cmd(self, event):\n    \"\"\"\n    Handles the keyboard shortcut input for category selection in the rating process.\n\n    This method updates the category variable based on the number key pressed by the user.\n    It adjusts the rating in the data structure and updates the navigation frame on the left side\n    to reflect the selected category.\n\n    Parameters:\n    - event: The event object containing details of the key press.\n    \"\"\"\n```",
                "next_cmd": "```python\ndef next_cmd(self, event=None):\n    \"\"\"\n    Advances to the next text item in the list, updates the display, and handles the navigation logic.\n\n    This method is bound to the right arrow key and the next button. It updates the text index to the next item,\n    updates the displayed text, and manages the navigation treeview to reflect the current position. If the end of\n    the list is reached, it does nothing. It also handles the display of ratings if they exist for the new text item.\n\n    Args:\n        event: The event that triggered this method, default is None. This is used to handle event bindings.\n    \"\"\"\n```",
                "prev_cmd": "```python\ndef prev_cmd(self, event=None):\n    \"\"\"\n    Navigate to the previous text item in the list.\n\n    This method decrements the text index to move to the previous item in the text list,\n    updates the display to show the previous text, and adjusts the GUI components accordingly.\n    If the current text index is at the start of the list, no action is taken.\n\n    Args:\n        event: An optional event parameter which is not used in the method.\n    \"\"\"\n```",
                "save_cmd": "```python\ndef save_cmd(self):\n    \"\"\"\n    Saves the current ratings to a file.\n\n    This method first undoes any shuffling of text entries if shuffling was applied.\n    It then prompts the user to choose a file name and file type (Excel, Libreoffice Calc, or CSV)\n    and saves the ratings to the specified file using the file validation method from the container.\n    \"\"\"\n```",
                "delete_cmd": "```python\ndef delete_cmd(self):\n    \"\"\"\n    Handles the deletion of the entire rating session after confirmation from the user.\n\n    This method prompts the user with a confirmation dialog asking if they want to discard\n    the entire rating session. If the user confirms, it resets the ratings, clears the\n    category variable, and updates the frame to reflect these changes.\n    \"\"\"\n```",
                "label_text": "```python\ndef label_text(self, event=None):\n    \"\"\"\n    Handles the labeling of text elements based on the selected category from the radio buttons or entry field.\n    Updates the internal ratings list, the navigation treeview, and the percentage of labeled items.\n\n    This method is triggered when a category is selected or changed in the GUI. It updates the ratings for the\n    current text element, modifies the navigation treeview to reflect the labeling status, and updates the\n    percentage of completed labels displayed on the GUI.\n\n    Args:\n        event: An optional event parameter that can be used to trigger this method from a GUI event.\n    \"\"\"\n```",
                "labeling_finished": "```python\ndef labeling_finished(self):\n    \"\"\"\n    Check if all text elements have been rated and prompt the user to save the ratings.\n\n    This method checks if the total number of ratings matches the number of text elements.\n    If all elements have been rated, it prompts the user with a message asking if they\n    want to save the ratings. If the user agrees, it triggers the save command.\n    \"\"\"\n```",
                "populate_percentage": "```python\ndef populate_percentage(self):\n    \"\"\"\n    Updates the percentage of rated text elements and adjusts the style of the percentage label based on the completion rate.\n\n    This method calculates the percentage of text elements that have been rated and updates the text of the percentage label.\n    It also changes the style of the label to reflect different levels of completion using color coding:\n    - Red for less than 20% completion\n    - Orange for 20% to 39% completion\n    - Yellow for 40% to 59% completion\n    - Light green for 60% to 79% completion\n    - Green for 80% to 100% completion\n    \"\"\"\n```",
                "home_cmd": "\"\"\"\nNavigate the user back to the main frame and optionally save the current session.\n\nThis method prompts the user with a dialog asking if they want to save the current rating session.\nIf the user chooses to save, the `save_cmd` method is called to handle the saving process.\nAfterwards, or if the user chooses not to save, the method initializes the main frames and displays the main frame.\n\nReturns:\n    None\n\"\"\"",
                "help_cmd": "```python\ndef help_cmd(self, event=None):\n    \"\"\"\n    Opens the help frame for the RateFrame.\n\n    This method triggers the display of the RateHelpFrame which provides\n    help and guidance on how to use the rating interface.\n\n    Args:\n        event: An optional event parameter that can be passed if the method\n               is triggered by an event. Defaults to None.\n    \"\"\"\n```",
                "update_frame": "```python\ndef update_frame(self, mode=None):\n    \"\"\"\n    Updates the frame by setting up the text, ratings, categories, and navigation based on the current state.\n\n    This method is responsible for initializing or updating the text display, ratings, and navigation elements\n    within the frame. It can also handle randomization of the text order if specified.\n\n    Args:\n        mode (str, optional): If set to \"do\", the text will be randomized. Defaults to None.\n    \"\"\"\n```",
                "RateFrame": "\"\"\"\nThe RateFrame class is designed to facilitate the interactive rating of text entries within a graphical user interface (GUI). It provides comprehensive functionality for managing text data, categorizing entries, navigating through items, and handling user interactions such as text selection, category assignment, and data manipulation.\n\nThis class integrates various components such as text display, navigation controls, category selection, and session management to offer a seamless rating experience. It supports operations like shuffling text entries, deleting categories or questions, saving sessions, and more. The class is structured to work within a larger application framework, typically receiving a container object that includes database and GUI configuration settings.\n\nKey functionalities include:\n- Displaying and navigating text entries.\n- Managing category inputs for ratings.\n- Handling user interactions through buttons, hotkeys, and entry fields.\n- Saving and deleting rating sessions.\n- Providing help and guidance on using the rating interface.\n\"\"\""
            }
        },
        {
            "global": {}
        }
    ],
    "C:\\Users\\t.kubera\\dev\\hackathon\\targets\\IIRA\\gui\\__init__.py": [
        "This file is empty."
    ]
}