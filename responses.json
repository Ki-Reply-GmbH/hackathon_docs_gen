{
    "C:\\Users\\t.kubera\\dev\\hackathon\\targets\\IIRA\\gui\\helperframes.py": [
        {
            "ProfileFrame": {
                "__init__": "```python\ndef __init__(self, container):\n    \"\"\"\n    Initialize a new instance of the ProfileFrame class, which is a Toplevel window.\n\n    This method sets up the GUI components for the profile management frame, including labels,\n    buttons, and menu options for creating, deleting, and switching profiles.\n\n    Args:\n    container (tk.Tk): The parent window for this Toplevel window.\n    \"\"\"\n```",
                "ok_cmd": "```python\ndef ok_cmd(self, event=None):\n    \"\"\"\n    Handles the 'Ok' button click or 'Return' key press event in the profile management interface.\n\n    This method checks if the user input is empty. If it is, the profile window is closed without creating a new profile.\n    If there is user input, it creates a new profile with the provided name, updates the profile label and menu,\n    and clears the input field. It also removes any widgets added to the separator frame.\n\n    Args:\n        event: The event that triggered this method, default is None. This is used to handle the 'Return' key event.\n    \"\"\"\n```",
                "populate_profile_label": "```python\ndef populate_profile_label(self):\n    \"\"\"Update the text of the profile name label with the active profile name.\"\"\"\n```",
                "populate_change_profile_menu": "```python\ndef populate_change_profile_menu(self):\n    \"\"\"\n    Populates the 'change profile' menu with radio buttons for each user profile available.\n\n    This method dynamically creates a radio button for each profile stored in the database interaction layer\n    and assigns a command to change the profile to the selected one. It configures the menu of the 'change_profile_mbutton'\n    Menubutton widget with these radio buttons, allowing the user to select and switch to different profiles.\n    \"\"\"\n```",
                "create_new_profile": "```python\ndef create_new_profile(self):\n    \"\"\"\n    Creates a new user profile by adding an input field to the GUI if it has not been added yet.\n\n    This method checks if the input field for entering a new profile name is already present.\n    If not, it adds a label and an entry widget to the separator frame for the user to input the new profile name.\n    The input is processed and used to create a new profile when the user presses the 'Return' key.\n    \"\"\"\n```",
                "change_profile": "\"\"\"\nChanges the active user profile to the selected profile and updates the profile label and menu.\n\nArgs:\n    profile_selection (str): The name of the profile to switch to.\n\"\"\"",
                "delete_profile": "```python\ndef delete_profile(self):\n    \"\"\"\n    Deletes the currently active profile if there are other profiles available.\n    If the active profile is the only one, it displays an error message prompting\n    the user to create a new profile before deleting the current one.\n    \"\"\"\n```",
                "ProfileFrame": "\"\"\"\nThe `ProfileFrame` class is designed to manage user profiles within a graphical user interface. It provides functionalities to create, delete, and switch between different user profiles. This class integrates with a parent GUI container and manages its own layout and user interactions through various buttons and menu options. The class handles events such as button clicks and key presses to appropriately respond to user actions like creating a new profile, changing to another profile, or deleting an existing profile. It dynamically updates GUI components such as profile labels and menus to reflect the current state of profiles.\n\"\"\""
            }
        },
        {
            "ScrollFrame": {
                "__init__": "```python\ndef __init__(self, container):\n    \"\"\"\n    Initialize a new instance of the ProfileFrame class, which is a Toplevel window.\n\n    This method sets up the GUI components for the profile management frame, including labels,\n    buttons, and menu options for creating, deleting, and switching profiles.\n\n    Args:\n    container (tk.Tk): The parent window for this Toplevel window.\n    \"\"\"\n```",
                "onFrameConfigure": "```python\ndef onFrameConfigure(self, event):\n    \"\"\"\n    Adjusts the scroll region of the canvas to encompass the entire viewport frame.\n\n    This method is called whenever the viewport frame is resized. It ensures that the\n    scrollable region of the canvas is updated to match the size of the viewport frame,\n    allowing for proper scrolling behavior.\n\n    Parameters:\n        event (tk.Event): The event that triggered this method, typically a configure event.\n    \"\"\"\n```",
                "onCanvasConfigure": "```python\ndef onCanvasConfigure(self, event):\n    \"\"\"\n    Adjusts the width of the canvas window to match the canvas width when the canvas size changes.\n\n    This method ensures that the viewport frame within the canvas adjusts its width to fill the\n    canvas whenever the canvas's width is altered, maintaining the layout's responsiveness.\n\n    Parameters:\n    - event: A tkinter event object containing information about the canvas configuration change.\n    \"\"\"\n```",
                "onMouseWheel": "```python\ndef onMouseWheel(self, event):\n    \"\"\"\n    Handles the mouse wheel event for scrolling the canvas vertically across different platforms.\n\n    This method adjusts the vertical scroll position of the canvas based on the mouse wheel movement.\n    It supports different scrolling increments and directions depending on the operating system.\n\n    Args:\n        event: A mouse event that contains information about the scroll action.\n\n    Platform-specific behavior:\n    - Windows: Scrolls by units, with a typical increment per wheel notch.\n    - MacOS (Darwin): Scrolls by a fixed amount per event, regardless of the wheel's notch count.\n    - Linux: Handles separate button events for scrolling up (Button-4) and down (Button-5).\n    \"\"\"\n```",
                "onEnter": "```python\ndef onEnter(self, event):\n    \"\"\"\n    Handles the mouse wheel scrolling when the cursor enters the viewport frame.\n\n    This method binds the appropriate mouse wheel scrolling events depending on the operating system.\n    For Linux, it binds 'Button-4' and 'Button-5' for scrolling. For other operating systems, it binds\n    the 'MouseWheel' event.\n\n    Args:\n        event: The event that triggered this method.\n    \"\"\"\n```",
                "onLeave": "```python\ndef onLeave(self, event):\n    \"\"\"\n    Unbinds the mouse wheel scroll events when the cursor leaves the control area.\n\n    This method is responsible for ensuring that the scroll functionality is disabled\n    when the mouse cursor is not over the scrollable area, preventing unintended scrolls\n    when the user interacts with other parts of the application.\n\n    Parameters:\n    - event: The event that triggers this method, typically a mouse leave event.\n    \"\"\"\n```",
                "ScrollFrame": "\"\"\"\nA ScrollFrame class in Tkinter designed to provide a scrollable frame within a GUI application.\n\nThis class manages a scrollable area using a canvas and a viewport frame. It includes functionality to dynamically adjust the scroll region and canvas size based on the frame's size changes. It also handles mouse wheel scrolling events across different platforms, ensuring that the scroll behavior is consistent and responsive to user interactions.\n\nThe class is typically used in applications where the content exceeds the available display area, requiring scroll bars to navigate through the content effectively. It encapsulates all the necessary bindings and configurations for scrolling, resizing, and event handling within a Tkinter environment.\n\"\"\""
            }
        },
        {
            "MainHelpFrame": {
                "MainHelpFrame": "\"\"\"\nA class designed to provide a comprehensive help framework for an application. This class includes methods for displaying help content, managing help windows, and interacting with user inputs to navigate through the help topics. It serves as the main interface for users seeking assistance and guidance on using the application.\n\"\"\""
            }
        },
        {
            "ScaleHelpFrame": {
                "ScaleHelpFrame": "\"\"\"\nA class designed to provide a graphical user interface component specifically for assisting users with scaling options. This class includes methods for initializing the component, updating its state based on user interactions, and handling specific events related to scaling adjustments. It is typically used in applications where dynamic scaling of elements or data visualization is required, providing a user-friendly interface to control these adjustments.\n\"\"\""
            }
        },
        {
            "ImportHelpFrame": {
                "ImportHelpFrame": "\"\"\"\nA class designed to provide a user interface frame for importing various types of data or resources. \nThis frame likely includes functionalities such as loading files, parsing data, and handling import errors.\n\"\"\""
            }
        },
        {
            "PrepAnalyseHelpFrame": {
                "__init__": "```python\ndef __init__(self, container):\n    \"\"\"\n    Initialize a new instance of the ProfileFrame class, which is a Toplevel window.\n\n    This method sets up the GUI components for the profile management frame, including labels,\n    buttons, and menu options for creating, deleting, and switching profiles.\n\n    Args:\n    container (tk.Tk): The parent window for this Toplevel window.\n    \"\"\"\n```",
                "ok_cmd": "```python\ndef ok_cmd(self, event=None):\n    \"\"\"\n    Handles the 'Ok' button click or 'Return' key press event in the profile management interface.\n\n    This method checks if the user input is empty. If it is, the profile window is closed without creating a new profile.\n    If there is user input, it creates a new profile with the provided name, updates the profile label and menu,\n    and clears the input field. It also removes any widgets added to the separator frame.\n\n    Args:\n        event: The event that triggered this method, default is None. This is used to handle the 'Return' key event.\n    \"\"\"\n```",
                "populate_profile_label": "```python\ndef populate_profile_label(self):\n    \"\"\"Update the text of the profile name label with the active profile name.\"\"\"\n```",
                "populate_change_profile_menu": "```python\ndef populate_change_profile_menu(self):\n    \"\"\"\n    Populates the 'change profile' menu with radio buttons for each user profile available.\n\n    This method dynamically creates a radio button for each profile stored in the database interaction layer\n    and assigns a command to change the profile to the selected one. It configures the menu of the 'change_profile_mbutton'\n    Menubutton widget with these radio buttons, allowing the user to select and switch to different profiles.\n    \"\"\"\n```",
                "create_new_profile": "```python\ndef create_new_profile(self):\n    \"\"\"\n    Creates a new user profile by adding an input field to the GUI if it has not been added yet.\n\n    This method checks if the input field for entering a new profile name is already present.\n    If not, it adds a label and an entry widget to the separator frame for the user to input the new profile name.\n    The input is processed and used to create a new profile when the user presses the 'Return' key.\n    \"\"\"\n```",
                "change_profile": "\"\"\"\nChanges the active user profile to the selected profile and updates the profile label and menu.\n\nArgs:\n    profile_selection (str): The name of the profile to switch to.\n\"\"\"",
                "delete_profile": "```python\ndef delete_profile(self):\n    \"\"\"\n    Deletes the currently active profile if there are other profiles available.\n    If the active profile is the only one, it displays an error message prompting\n    the user to create a new profile before deleting the current one.\n    \"\"\"\n```",
                "PrepAnalyseHelpFrame": "\"\"\"\nThe `PrepAnalyseHelpFrame` class is designed to manage user profiles within a graphical user interface. It provides functionality to create, delete, switch, and manage user profiles. The class integrates various GUI components such as labels, buttons, and menus to facilitate these operations. It is intended to be used as a Toplevel window in a larger application, where managing different user profiles is necessary.\n\nThis class handles the initialization of the GUI components, updating of profile labels and menus, and processing user interactions such as button clicks and menu selections to effectively manage the profiles. It ensures that the user can smoothly navigate through different profiles, create new ones, or modify existing ones within the application environment.\n\"\"\""
            }
        },
        {
            "ResultsHelpFrame": {
                "__init__": "```python\ndef __init__(self, container):\n    \"\"\"\n    Initialize a new instance of the ProfileFrame class, which is a Toplevel window.\n\n    This method sets up the GUI components for the profile management frame, including labels,\n    buttons, and menu options for creating, deleting, and switching profiles.\n\n    Args:\n    container (tk.Tk): The parent window for this Toplevel window.\n    \"\"\"\n```",
                "ok_cmd": "```python\ndef ok_cmd(self, event=None):\n    \"\"\"\n    Handles the 'Ok' button click or 'Return' key press event in the profile management interface.\n\n    This method checks if the user input is empty. If it is, the profile window is closed without creating a new profile.\n    If there is user input, it creates a new profile with the provided name, updates the profile label and menu,\n    and clears the input field. It also removes any widgets added to the separator frame.\n\n    Args:\n        event: The event that triggered this method, default is None. This is used to handle the 'Return' key event.\n    \"\"\"\n```",
                "populate_profile_label": "```python\ndef populate_profile_label(self):\n    \"\"\"Update the text of the profile name label with the active profile name.\"\"\"\n```",
                "populate_change_profile_menu": "```python\ndef populate_change_profile_menu(self):\n    \"\"\"\n    Populates the 'change profile' menu with radio buttons for each user profile available.\n\n    This method dynamically creates a radio button for each profile stored in the database interaction layer\n    and assigns a command to change the profile to the selected one. It configures the menu of the 'change_profile_mbutton'\n    Menubutton widget with these radio buttons, allowing the user to select and switch to different profiles.\n    \"\"\"\n```",
                "create_new_profile": "```python\ndef create_new_profile(self):\n    \"\"\"\n    Creates a new user profile by adding an input field to the GUI if it has not been added yet.\n\n    This method checks if the input field for entering a new profile name is already present.\n    If not, it adds a label and an entry widget to the separator frame for the user to input the new profile name.\n    The input is processed and used to create a new profile when the user presses the 'Return' key.\n    \"\"\"\n```",
                "change_profile": "\"\"\"\nChanges the active user profile to the selected profile and updates the profile label and menu.\n\nArgs:\n    profile_selection (str): The name of the profile to switch to.\n\"\"\"",
                "delete_profile": "```python\ndef delete_profile(self):\n    \"\"\"\n    Deletes the currently active profile if there are other profiles available.\n    If the active profile is the only one, it displays an error message prompting\n    the user to create a new profile before deleting the current one.\n    \"\"\"\n```",
                "ResultsHelpFrame": "\"\"\"\nA class designed to manage user profiles within a GUI application, specifically handling the creation, deletion, and switching of profiles. This class integrates various GUI components such as labels, buttons, and menus to facilitate user interaction with profile management. It provides functionalities to populate profile-related UI elements, handle user inputs for profile operations, and dynamically update the interface based on the current profile state.\n\"\"\""
            }
        },
        {
            "RateHelpFrame": {
                "__init__": "```python\ndef __init__(self, container):\n    \"\"\"\n    Initialize a new instance of the ProfileFrame class, which is a Toplevel window.\n\n    This method sets up the GUI components for the profile management frame, including labels,\n    buttons, and menu options for creating, deleting, and switching profiles.\n\n    Args:\n    container (tk.Tk): The parent window for this Toplevel window.\n    \"\"\"\n```",
                "ok_cmd": "```python\ndef ok_cmd(self, event=None):\n    \"\"\"\n    Handles the 'Ok' button click or 'Return' key press event in the profile management interface.\n\n    This method checks if the user input is empty. If it is, the profile window is closed without creating a new profile.\n    If there is user input, it creates a new profile with the provided name, updates the profile label and menu,\n    and clears the input field. It also removes any widgets added to the separator frame.\n\n    Args:\n        event: The event that triggered this method, default is None. This is used to handle the 'Return' key event.\n    \"\"\"\n```",
                "populate_profile_label": "```python\ndef populate_profile_label(self):\n    \"\"\"Update the text of the profile name label with the active profile name.\"\"\"\n```",
                "populate_change_profile_menu": "```python\ndef populate_change_profile_menu(self):\n    \"\"\"\n    Populates the 'change profile' menu with radio buttons for each user profile available.\n\n    This method dynamically creates a radio button for each profile stored in the database interaction layer\n    and assigns a command to change the profile to the selected one. It configures the menu of the 'change_profile_mbutton'\n    Menubutton widget with these radio buttons, allowing the user to select and switch to different profiles.\n    \"\"\"\n```",
                "create_new_profile": "```python\ndef create_new_profile(self):\n    \"\"\"\n    Creates a new user profile by adding an input field to the GUI if it has not been added yet.\n\n    This method checks if the input field for entering a new profile name is already present.\n    If not, it adds a label and an entry widget to the separator frame for the user to input the new profile name.\n    The input is processed and used to create a new profile when the user presses the 'Return' key.\n    \"\"\"\n```",
                "change_profile": "\"\"\"\nChanges the active user profile to the selected profile and updates the profile label and menu.\n\nArgs:\n    profile_selection (str): The name of the profile to switch to.\n\"\"\"",
                "delete_profile": "```python\ndef delete_profile(self):\n    \"\"\"\n    Deletes the currently active profile if there are other profiles available.\n    If the active profile is the only one, it displays an error message prompting\n    the user to create a new profile before deleting the current one.\n    \"\"\"\n```",
                "RateHelpFrame": "\"\"\"\nThe `RateHelpFrame` class is designed to manage user profiles within a GUI application. It provides functionality to create, delete, and switch between different user profiles. The class also handles the graphical interface elements necessary for profile management, such as input fields, labels, buttons, and menus.\n\nThis class is responsible for initializing the profile management frame as a Toplevel window, populating profile-related labels and menus, and handling user interactions such as button clicks and key presses to manage profiles effectively.\n\"\"\""
            }
        },
        {
            "global": {}
        }
    ],
    "C:\\Users\\t.kubera\\dev\\hackathon\\targets\\IIRA\\core\\metrics.py": [
        {
            "Metrics": {
                "__init__": "\"\"\"\nInitialize the Metrics object with specified parameters for analysis.\n\nParameters:\n    scale_format (str): The format of the scale used ('ordinal' or 'nominal').\n    categories (list): A list of categories used in the ratings.\n    ratings (DataFrame): A pandas DataFrame containing the ratings data.\n    weights (list): A list of weights corresponding to each category.\n\nThe constructor initializes the Metrics object, sets up the analysis type based on the scale format,\nand handles exceptions during the creation of the analysis object. It also sets the precision for decimal operations.\n\"\"\"",
                "cohens_kappa": "\"\"\"\nCalculates and returns the Cohen's Kappa coefficient value for the current dataset.\n\nThis method retrieves the Cohen's Kappa coefficient, a statistical measure of inter-rater reliability\nor agreement for qualitative (categorical) items, from the analysis object which is assumed to be\npreviously set up with the appropriate data and configuration.\n\nReturns:\n    float: The Cohen's Kappa coefficient value.\n\"\"\"",
                "fleiss_kappa": "```python\ndef fleiss_kappa(self):\n    \"\"\"\n    Calculate and return the Fleiss' kappa coefficient value for inter-rater reliability.\n\n    Fleiss' kappa is a statistical measure for assessing the reliability of agreement between a fixed number of raters when assigning categorical ratings to a number of items.\n\n    Returns:\n        float: The estimated Fleiss' kappa coefficient value.\n    \"\"\"\n```",
                "gwets_ac": "\"\"\"\nCalculates and returns the Gwet's AC coefficient value from the analysis results.\n\nReturns:\n    float: The Gwet's AC coefficient value.\n\"\"\"",
                "krippendorfs_alpha": "\"\"\"\nCalculates and returns the Krippendorff's alpha coefficient value for inter-rater reliability.\n\nThis method utilizes the 'krippendorff' function from the 'irrCAC' library to compute the Krippendorff's alpha,\nwhich is a statistical measure of the agreement achieved when coding a set of units based on the scale of measurement.\n\nReturns:\n    float: The estimated Krippendorff's alpha coefficient value.\n\"\"\"",
                "g_index": "\"\"\"\nCalculates the G index, a measure of inter-rater reliability, for the given categories and ratings.\n\nThe G index is a normalized measure that adjusts the observed agreement proportion (p_a) by the expected agreement due to chance. This method assumes that there are exactly two replications of ratings per subject.\n\nReturns:\n    float: The G index rounded to four decimal places.\n\"\"\"",
                "icc": "\"\"\"Calculates the Intraclass Correlation Coefficient (ICC) for assessing the reliability of ratings.\n\nThis method constructs a DataFrame suitable for analysis with the `pingouin.intraclass_corr` function, which computes the ICC. It organizes the ratings data into a format with targets, raters, and ratings, and handles missing data by omitting them.\n\nReturns:\n    pandas.DataFrame: A DataFrame containing the ICC results, rounded to four decimal places.\n\"\"\"",
                "overall_agreement": "\"\"\"\nCalculates the overall agreement among raters for a given set of ratings and categories.\n\nThis method computes the proportion of agreement among raters by considering either\na two-replication scenario or a multi-replication scenario. In the two-replication\nscenario, it checks if both ratings for each subject match and calculates the proportion\nof these matches. In the multi-replication scenario, it considers the agreement across\nall replications for each subject and category, adjusting for the number of possible\npairings.\n\nReturns:\n    decimal.Decimal: The overall agreement proportion.\n\nRaises:\n    ValueError: If there are less than two replications per subject, making it\n                impossible to calculate an overall agreement.\n\"\"\"",
                "Metrics": "\"\"\"\nThe Metrics class is designed to facilitate the analysis of inter-rater reliability and agreement for categorical data. It provides methods to compute various statistical measures such as Cohen's Kappa, Fleiss' Kappa, Gwet's AC, Krippendorff's Alpha, G index, Intraclass Correlation Coefficient (ICC), and overall agreement among raters. This class is initialized with parameters that define the scale format, categories, ratings data, and weights, which are used across different methods to perform specific reliability assessments. The class aims to provide a comprehensive toolkit for analyzing the consistency and reliability of ratings provided by different raters, making it suitable for statistical studies in fields such as psychology, medical research, and any other domain where categorical ratings are used.\n\"\"\""
            }
        },
        {
            "global": {
                "map_metrics": "\"\"\"\nMaps human-readable metric names to their corresponding method names in the analysis library.\n\nParameters:\n    metric (str): The name of the metric to map.\n\nReturns:\n    str: The method name corresponding to the given metric.\n\nRaises:\n    ValueError: If the metric name does not match any known metrics.\n\"\"\""
            }
        }
    ]
}